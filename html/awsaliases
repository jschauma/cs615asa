# This file contains a few shell aliases and functions
# that should it easier for you to work with AWS EC2
# within the context of the class CS615 System
# Administration.
#
# Author: Jan Schaumann <jschauma@netmeister.org>
#         @jschauma
#
# See https://stevens.netmeister.org/615/ for more
# information.
#
# This file is in the public domain.

###
# Generic handling of instances first
###

alias _aedi='aws ec2 describe-instances --output json'

# First, I'm too lazy to always type
# 'aws ec2 run-instances ...'
#
# In addition, I use a separate SSH key for AWS
# resources associated with Stevens.  If you have only
# a default SSH key, then you do not need to include
# that option here.
alias instance='aws ec2 run-instances --key-name stevens --image-id --output json'

# Next, I want my instances to be IPv4/IPv6 dual stack
# enabled.  AWS does not offer this by default, but if
# you configure an appropriate subnet and security
# group as described in
# https://www.netmeister.org/blog/ec2-ipv6.html, then
# you can grab the right resources to specify.
#
# We're using a function instead of an alias here
# because we are passing arguments.
launchInstance() {
	local ami=${1}
	local itype=${2:-"t3.micro"}
	
	subnet=$(aws ec2 describe-subnets --output json | jq -r '.Subnets[] | select( .Tags[]? | select(.Value == "dualstack")).SubnetId')
	sg=$(aws ec2 describe-security-groups --output json | jq -r '.SecurityGroups [] | select( .GroupName == "dualstack").GroupId')
	instance ${ami}				\
		--instance-type ${itype}	\
		--subnet-id "${subnet}"		\
		--security-group-ids "${sg}" |	\
		jq -r '.Instances[].InstanceId'
}

# Often I have an instance-id, but want to know what
# the hostname associated with it is.  Specifically,
# after we start an instance, we don't immedately get
# the hostname back, so use the 'iname' function
# to get it:
iname() {
	_aedi --instance-ids $@ | \
		jq -r ".Reservations[].Instances[].PublicDnsName"
}

# Basically the inverse:  I have an instance name, but
# I want to get the instance ID.
instanceId() {
	local hname="${1}"
	if [ x"${hname}" = x"-h" ]; then
		echo "Usage: instanceId <hostname>" >&2
		return 0
	fi
	if ! expr "${hname}" : "ec2-" >/dev/null 2>&1 ; then
		echo "'${hname}' does not look like an EC2 name to me." >&2
		return 0
	fi
	_aedi --filters Name=dns-name,Values="${hname}" | \
		jq -r ".Reservations[].Instances[].InstanceId"
}

# After we start an instance, we have to wait for it
# to come up.  Note: this uses the 'iname' function
# above to report the hostname when we think it's up.
ec2wait() {
	local ami descr n
	local user="root"
	local sleep=60
	if ! expr "$@" : ".*i-[0-9a-f]*" >/dev/null 2>&1; then
		echo "That doesn't look like an instance ID." >&2
		return 1;
	fi
	aws ec2 wait instance-running --output json --instance-ids $@
	# "running" does not mean SSH is up, so give it a bit more time,
	# guessing different time intervals for different OS versions
	ami=$(_aedi  --instance-ids "$@" | jq -r '.Reservations[0].Instances[0].ImageId')
	if [ -n "${ami}" ]; then
		descr=$(aws ec2 describe-images --image-id "${ami}" |
			jq -r '.Images[0].Description')
		if expr "${descr}" : "OmniOS" >/dev/null 2>&1 ; then
			sleep=120
			user="omnios"
		elif expr "${descr}" : "FreeBSD" >/dev/null 2>&1 ; then
			sleep=140
			user="ec2-user"
		elif expr "${descr}" : "Debian" >/dev/null 2>&1 ; then
			user="admin"
		elif expr "${descr}" : "Fedora" >/dev/null 2>&1 ; then
			user="fedora"
		elif expr "${descr}" : "Canonical" >/dev/null 2>&1 ; then
			user="ubuntu"
		fi
	fi
	echo "$@"
	iname $@
	echo "${user}"
	echo
	echo "Sleeping ${sleep} seconds to wait for ssh:"
	n=5
	while [ ${n} -lt ${sleep} ]; do
		/bin/echo -n "."
		sleep 5
		n=$(( n + 5 ))
	done
	echo
	echo "Ready."
}

# Use this to see which instances you currently
# have, regardless of their state.
alias instances='_aedi | jq -r ".Reservations[].Instances[].InstanceId"'

# Same thing, but printing the hostnames instead:
alias inames='_aedi | jq -r ".Reservations[].Instances[].PublicDnsName" | grep .'

# ...but often we only care about which instances are
# currently running:
alias running='_aedi --query Reservations[*].Instances[*].[InstanceId] --filters Name=instance-state-name,Values=running | jq -r ".[] | .[] | .[]"'

# Same thing, but printing hostnames isntead:
alias running-names='_aedi --query Reservations[*].Instances[*].[PublicDnsName] --filter Name=instance-state-name,Values=running | jq -r ".[] | .[] | .[]"'

# To get a listing of hostnames with instance-ids:
alias instance-id-and-names='_aedi | jq -r ".Reservations[].Instances[] | \"\(.PublicDnsName) \(.InstanceId)\""'

# When you want to kill all instances instead of going
# one-by-one.  We don't pipe into 'termInstance'
# because that may not be defined when xargs runs.
alias kill-all-instances='instances | xargs aws ec2 terminate-instances --instance-ids'

# A generic function to invoke an EC2 operation on a
# single instance-id or hostname.
_instanceOperation() {
	local op="${1}"
	local hname="${2}"
	local arg="--instance-ids"
	local out="json"

	if [ x"${hname}" = x"-h" ]; then
		echo "Supported arguments: <hostname|id>" >&2
		return 0
	fi
	if expr "${hname}" : "ec2-" >/dev/null 2>&1 ; then
		hname="$(instanceId ${hname})"
	elif ! expr "${hname}" : "i-" >/dev/null 2>&1 ; then
		echo "<hostname|id> should match 'ec2-*' or 'i-*'" >&2
		return 0
	fi

	if [ "${op}" = "get-console-output" ]; then
		arg="--instance-id"
		out="text"
	fi
	aws ec2 ${op} --output ${out} ${arg} "${hname}"
}

console() {
	_instanceOperation get-console-output "${1}"
}

termInstance() {
	_instanceOperation terminate-instances "${1}"
}

startInstance() {
	_instanceOperation start-instances "${1}"
}

stopInstance() {
	_instanceOperation stop-instances "${1}"
}


###
# Generic handling of volumes next:
###

# Create a new volume of size 1GB in us-east-1a unless
# specified otherwise, e.g., "newVolume 3 us-west-1"
newVolume() {
	if [ x"${1}" = x"-h" ]; then
		echo "Usage: newVolume [size in GB] [availability-zone]"
		echo "       default: 1, us-east-1a"
		return 0
	fi
	aws ec2 create-volume --output json --size "${1:-1}" --availability-zone "${2:-us-east-1a}" | \
		jq -r ".VolumeId"
}

# We often attach just one volume to a given instance,
# so let's have a default function to save ourselves
# some typing.
attachVolume() {
	if [ x"${1}" = x"-h" ]; then
		echo "Usage: attachVolume volume-id instance-id [device]"
		echo "       default device: /dev/sdf"
		return 0
	fi
	if [ -z "${2}" ]; then
		echo "Usage: attachVolume vol-id instance-id [device]" >&2
		return 1
	fi
	aws ec2 attach-volume --output json --volume-id "${1}" --instance-id "${2}" --device "${3:-/dev/sdf}"
}

# Same for detachingk, but we don't need to know the
# instance-id:
detachVolume() {
	if [ -z "${1}" ]; then
		echo "Usage: detachVolume vol-id" >&2
		return 1
	fi
	local instance="$(aws ec2 describe-volumes --output json --volume-id "${1}" | \
				jq -r '.Volumes[].Attachments[].InstanceId')"
	if [ -z "${instance}" ]; then
		echo "Volume ${1} not attached to any instance?" >&2
		return
	fi
	aws ec2 detach-volume --output json --volume-id "${1}" --instance-id "${instance}" 
}

# Like 'instances', but for EBS volumes:
alias volumes='aws ec2 describe-volumes --output json | jq -r ".Volumes[].VolumeId"'

# Like 'termInstance', but for a single EBS volume:
alias del-volume='aws ec2 delete-volume --volume-id'

# Like 'killallInstances', but for EBS volumes:
alias kill-all-volumes='volumes | xargs -n 1 aws ec2 delete-volume --volume-id'

# A simple function to determine your current AWS bill
# for the calendar month.
#
# You need read access to the 'Cost Explorer Service';
# create an IAM policy that grants permissions to
# 'Read' and 'List' under "ce:".  (This may require
# additional "Anomaly" resources.)
awsCurrentBill() {
	local readonly start="$(date -r $(( $(date +%s) - (86400 * 30) )) +%Y-%m-%d)"
	local readonly end="$(date +%Y-%m-%d)"
	local num

	num=$(aws ce get-cost-and-usage					\
		--output json						\
		--time-period Start=${start},End=${end}			\
		--granularity MONTHLY					\
		--metrics UnblendedCost					\
		--query 'ResultsByTime[*].Total.[UnblendedCost]' |	\
		jq '.[][0].Amount  | tonumber*100 | round/100')

	if [ -z "${num}" ]; then
		return
	fi

	num=$(echo "0+${num}" | tr '\n' '+' | sed -e 's/\+$//' | xargs | bc)

	echo "AWS Billing Period ${start} - ${end}: \$${num}"
}

awsListResources() {
	local spacer=""
	local amis snapshots instances region volumes
	local regions="${1}"

	if [ -z "${regions}" ]; then
		regions=$(aws configure get region)
	elif [ x"${regions}" = x"all" ]; then
		regions=$(aws ec2 describe-regions | jq -r '.Regions[].RegionName')
	fi

	for region in ${regions}; do
		amis=$(aws ec2 describe-images --region ${region} --owner self | \
			jq -r '.Images[] | "\(.ImageId) \(.BlockDeviceMappings[0].Ebs.SnapshotId) \"\(.Description)\""')
		if [ -n "${amis}" ]; then
			/bin/echo -n "${spacer}"
			echo "You have the following AMIs in ${region}:"
				echo "${amis}"
			spacer="
"
		fi
	done

	for region in ${regions}; do
		snapshots=$(aws ec2 describe-snapshots --region ${region} --owner self | \
				jq -r '.Snapshots[] | "\(.SnapshotId) \(.StartTime)"')
		if [ -n "${snapshots}" ]; then
			/bin/echo -n "${spacer}"
			echo "You have the following snapshots in ${region}:"
			echo "${snapshots}"
			spacer="
"
		fi
	done

	for region in ${regions}; do
		instances=$(aws ec2 describe-instances --region ${region} | \
				jq -r '.Reservations[].Instances[] | "\(.InstanceId) (\(.State.Name)) \(.PublicDnsName)"')
		if [ -n "${instances}" ]; then
			/bin/echo -n "${spacer}"
			echo "You have the following instances in ${region}:"
			echo "${instances}"
			spacer="
"
		fi
	done

	for region in ${regions}; do
		volumes=$(aws ec2 describe-volumes --region ${region} |	\
				jq -r '.Volumes[] | "\(.VolumeId) \(.CreateTime) \(.Attachments[0].InstanceId)"')
		if [ -n "${volumes}" ]; then
			/bin/echo -n "${spacer}"
			echo "You have the following volumes in ${region}:"
			echo "${volumes}"
			spacer="
"
		fi
	done

	awsS3Usage "${spacer}"
}

awsS3Usage() {
	local buckets
	local b
	local usage
	local spacer="${1:-""}"

	buckets=$(aws s3api list-buckets --query "Buckets[].Name" | \
			jq -r '.[]')

	if [ -n "${buckets}" ]; then
		/bin/echo -n "${spacer}"
		echo "You have the following S3 buckets:"
		echo ${buckets}
		spacer="
"
	fi

	for b in ${buckets}; do
		usage=$(aws s3 ls s3://${b} --recursive --summarize --human-readable | tail -2)
		if [ $(echo "${usage}" | awk '{print $3; exit; }') -gt 0 ]; then
			/bin/echo -n "${spacer}"
			echo "${b}"
			echo "${usage}"
			spacer="
"
		fi
	done
}

###
# Specific instances
###

# I usually have aliases for the latest stable version
# of some common OS.  These generally change every few
# months when new releases are made available.
#
# Unless noted otherwise, these AMIs are in us-east-1.

# https://wiki.debian.org/Cloud/AmazonEC2Image/
# Log in as "admin".
# Debian 12 ("Bookworm") amd64
alias start-debian='launchInstance ami-0e365edd3d30d031b'

# https://omniosce.org/setup/aws
# needs t3.micro; log in as "omnios"
alias start-omnios='launchInstance ami-0669dd7b1ff900fcc'

# https://alt.fedoraproject.org/cloud/
# Log in as "fedora".
#alias start-fedora='launchInstance ami-08b4ee602f76bff79'
# Fedora Cloud 39
alias start-fedora='launchInstance ami-0746fc234df9c1ee0'

# https://cloud-images.ubuntu.com/locator/ec2/
# Log in as "ubuntu". 
# 16.04 LTS
alias start-ubuntu='launchInstance ami-0b0ea68c435eb488d'

# https://www.freebsd.org/releases/
# Log in as "ec2-user".
# 13.2R
alias start-freebsd='launchInstance ami-0fe92206920260384'

# https://mail-index.netbsd.org/netbsd-users/2021/01/22/msg026460.html
# https://stevens.netmeister.org/615/netbsd-amis.html
# Log in as "root":
alias start-netbsd='launchInstance ami-08b87fed21cce91cb t4g.nano'
alias start-netbsd-arm='start-netbsd'
# Log in as "ec2-user":
alias start-netbsd-amd64='launchInstance ami-05ffda7ac6da57de1'

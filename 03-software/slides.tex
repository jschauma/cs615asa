%https://manybutfinite.com/post/how-computers-boot-up/
 
% CS615A System Administration
% Author: Jan Schaumann <jschauma@netmeister.org>

\special{! TeXDict begin /landplus90{true}store end }
\newcommand{\smallish}{\fontsize{16}{16}\selectfont}

\documentclass[xga]{xdvislides}
\usepackage[landscape]{geometry}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{colordvi}
\usepackage{tabularx}
\usepackage{multirow}

\begin{document}
\setfontphv

%%% Headers and footers
\lhead{\slidetitle}                               % default:\lhead{\slidetitle}
\chead{CS615 - System Administration}% default:\chead{\relax}
\rhead{Slide \thepage}                       % default:\rhead{\sectiontitle}
\lfoot{\Gray{Lecture 03: Software Installation Concepts}}% default:\lfoot{\slideauthor}
\cfoot{\relax}                               % default:\cfoot{\relax}
\rfoot{\Gray{\today}}

\vspace*{\fill}
\begin{center}
	\Hugesize
		CS615 - System Administration\\ [1em]
		Filesystem and OS Boot Process Concepts \\ [1em]
	\hspace*{5mm}\blueline\\ [1em]
	\Normalsize
		Department of Computer Science\\
		Stevens Institute of Technology\\
		Jan Schaumann\\
		\verb+jschauma@stevens.edu+ \\
		\verb+https://stevens.netmeister.org/615/+
\end{center}
\vspace*{\fill}

\newpage
\vspace*{\fill}
\begin{center}
	\Hugesize
		Basic Filesystem Concepts\\ [1em]
	\hspace*{5mm}
	\blueline\\
	\hspace*{5mm}\\
		The UNIX Filesystem
\end{center}
\vspace*{\fill}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.

\subsection{Let's pretend we're a filesystem...}

\begin{verbatim}
aws ec2 create-volume --size 1 --availability-zone us-east-1d

aws ec2 attach-volume --volume-id  XXX --instance-id XXX --device /dev/sda3

dmesg

for i in $(seq $((1024 * 128))); do
        printf '\0\0\0\0\0\0\0\0'
done | dd of=/dev/xbd2d
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.95]{pics/bucket.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\begin{center}
\includegraphics[scale=0.95]{pics/two-buckets.eps} \\
\end{center}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.95]{pics/buckets.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\begin{center}
\includegraphics[scale=0.95]{pics/one-bucket-full.eps} \\
\end{center}

\subsection{Let's pretend we're a filesystem...}

Creating a 'file':
\begin{verbatim}
echo -n meow | dd of=/dev/xbd2d

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.5]{pics/one-bucket-full.eps}
\hspace*{5mm}
\includegraphics[scale=0.6]{pics/cat-in-bucket.eps}
\end{center}
\vspace*{\fill}

\subsection{Let's pretend we're a filesystem...}

Each file can be up to 4096 bytes in size:
\begin{verbatim}
echo -n meow | dd of=/dev/xbd2d

dd if=/dev/xbd2d 2>/dev/null | hexdump -C

echo -n miumiu | dd of=/dev/xbd2d bs=1 seek=4096

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.95]{pics/two-cats-one-bucket.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Let's pretend we're a filesystem...}

We can store data for multiple files in a single
bucket:
\begin{verbatim}
printf 'meow' | dd of=/dev/xbd2d
printf 'miumiu' | dd of=/dev/xbd2d bs=1 seek=32

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\begin{center}
\includegraphics[scale=0.9]{pics/several-cats.eps} \\
\end{center}

\subsection{Let's pretend we're a filesystem...}

We can store data for multiple files in a single
bucket:
\begin{verbatim}
printf 'meow miu meow miu meow miu meow ' | dd of=/dev/xbd2d
printf 'miumiu miau miao miauw miaow ' | dd of=/dev/xbd2d bs=1 seek=32
printf 'hiss hiss' | dd of=/dev/xbd2d bs=1 seek=64
printf 'hiss hiss' | dd of=/dev/xbd2d bs=1 seek=96

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C
\end{verbatim}

\subsection{Let's pretend we're a filesystem...}

New format: identifier followed by data.
\begin{verbatim}
printf '\x1meow miu meow miu meow miu meow ' | dd of=/dev/xbd2d
printf '\x2miumiu miau miao miauw miaow ' | dd of=/dev/xbd2d bs=1 seek=512
printf '\x3hiss hiss' | dd of=/dev/xbd2d bs=1 seek=1024
printf '\x4hiss hiss' | dd of=/dev/xbd2d bs=1 seek=1535

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=1.0]{pics/numbered-cats.eps}
\end{center}
\vspace*{\fill}


\subsection{Let's pretend we're a filesystem...}

Quick note: removing a file does not "delete" the
data:
\begin{verbatim}
dd if=/dev/rxbd2a 2>/dev/null | hexdump -C

rm /mnt/newfile

dd if=/dev/rxbd2a 2>/dev/null | hexdump -C
\end{verbatim}



\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
What's in a file?
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.225]{pics/nutrition-facts.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Let's pretend we're a filesystem...}

New format: identifier, permission, owner, group, data.
\begin{verbatim}
printf '\x1\x7\x4\x4\x0\x0meow miu meow miu meow miu meow ' | dd of=/dev/xbd2d
printf '\x2\x7\x4\x4\x1\x1purrrrrr' | dd of=/dev/xbd2d bs=1 seek=4096
\end{verbatim}

\subsection{Let's pretend we're a filesystem...}

New format: identifier, permission, owner, group, data.
\begin{verbatim}
printf '\x1\x7\x4\x4\x0\x0meow miu meow miu meow miu meow ' | dd of=/dev/xbd2d
printf '\x2\x7\x4\x4\x1\x1purrrrrr' | dd of=/dev/xbd2d bs=1 seek=4096
\end{verbatim}
\vspace{.5in}
Problem: what if we have a file $>$4K?

\subsection{Let's pretend we're a filesystem...}

New format: separate meta-data from data
\begin{itemize}
	\item meta-data (16 bytes total, LE):
		\begin{itemize}
			\item identifier (2 bytes)
			\item permission (4 bytes)
			\item owner (1 byte)
			\item group (1 byte)
			\item size (4 bytes)
			\item offset (4 bytes)
		\end{itemize}
	\item data stored in separate area
\end{itemize}
\smallish
\begin{verbatim}
printf '\x1\x0\x0\x7\x4\x4\x0\x0\x20\x0\x0\x0\x0\x1\x0\x0' | dd of=/dev/xbd2d
printf 'meow miu meow miu meow miu meow ' | dd of=/dev/xbd2d bs=1 seek=4096
printf '\x2\x0\x0\x7\x4\x4\x1\x1\x8\x0\x0\x0\x20\x10\x0\x0' | dd of=/dev/xbd2d bs=1 seek=16
printf 'purrrrrr' | dd of=/dev/xbd2d bs=1 seek=4128
\end{verbatim}
\Normalsize
(What limitations do we have now?)

\subsection{A different "filesystem" format}
\begin{verbatim}
echo "hello world" > /root/newfile

tar cf - /root | dd of=/dev/xbd2d

dd if=/dev/xbd2d count=512 2>/dev/null | hexdump -C

dd if=/dev/xbd2d | tar tvf -
\end{verbatim}
\vspace{1in}
See also: \verb+https://stevens.netmeister.org/615/tar.html+

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.
\\

Components of the Berkeley Fast Filesystem:
\\

\newcolumntype{S}{>{\centering\arraybackslash} m{.4\linewidth} }
\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item set of {\em inode} storage cells
\end{itemize}
{\tt df -i}
& \multirow{2}{*}{\includegraphics[scale=0.5]{pics/buckets.eps}} \\
\end{tabular}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.
\\

Components of the Berkeley Fast Filesystem:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item set of {\em inode} storage cells
	\item set of scattered ``superblocks''
\end{itemize}
{\tt newfs -b 4096 -f 512 xbd2d}
& \multirow{2}{*}{\includegraphics[scale=0.3]{pics/lego.eps}} \\
\end{tabular}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.
\\

Components of the Berkeley Fast Filesystem:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item set of {\em inode} storage cells
	\item set of scattered ``superblocks''
	\item map of disk blocks
\end{itemize}
{\tt dumpfs -v xbd2}
& \multirow{2}{*}{\includegraphics[scale=0.5]{pics/map.eps}} \\
\end{tabular}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.
\\

Components of the Berkeley Fast Filesystem:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item set of {\em inode} storage cells
	\item set of scattered ``superblocks''
	\item map of disk blocks
	\item block usage summary
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=0.5]{pics/tetris.eps}} \\
\end{tabular}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
The filesystem is responsible for storing the data on the disk.
So to read/write data, it needs to know in which physical blocks the actual
data is located; ie how to map files to the disk blocks.
\\

Components of the Berkeley Fast Filesystem:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item set of {\em inode} storage cells
	\item set of scattered ``superblocks''
	\item map of disk blocks
	\item block usage summary
	\item set of data blocks
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=0.3]{pics/block.eps}} \\
\end{tabular}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
\begin{center}
	\includegraphics[scale=0.8]{pics/ufs-details.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
Information stored in an {\em inode}:
\begin{itemize}
	\item user owner and group owner ID's
	\item file type
		\begin{itemize}
			\item (regular ('r'), directory ('d'), special ('c', 'b'), symlink ('l'), socket ('s'), fifo ('p'))
		\end{itemize}
	\item access mode (permissions)
	\item file access and modification time
	\item file status modification time
	\item number of links to the file
	\item size of the file
	\item disk device containing this file
\end{itemize}

\begin{verbatim}
$ stat /etc/passwd
\end{verbatim}

\subsection{Let's {\em not} pretend we're a filesystem...}
\begin{verbatim}
dumpfs xbd2

disklabel xbd2

newfs -b 4096 -f 512 xbd2a

mount /dev/xbd2a /mnt

echo hello world > /mnt/newfile

dd if=/dev/rxbd2a 2>/dev/null | hexdump -C

dumpfs xbd2

dumpfs -v -i xbd2
\end{verbatim}

\newpage
\vspace*{\fill}
\begin{center}
    \Hugesize
        Hooray! \\ [1em]
    \hspace*{5mm}
    \blueline\\
    \hspace*{5mm}\\
        5 Minute Break
\end{center}
\vspace*{\fill}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
\end{itemize}


\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
	\item which the kernel handles for the OS
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
	\item which the kernel handles for the OS
	\item which is running in a virtual machine
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
	\item which the kernel handles for the OS
	\item which is running in a virtual machine
	\item which is running on top of a hypervisor
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
	\item which the kernel handles for the OS
	\item which is running in a virtual machine
	\item which is running on top of a hypervisor
	\item which uses firmware to manage various components
\end{itemize}

\subsection{Down the stack we go}
Consider a website on an AWS EC2 instance...
\\

...it might:

\begin{itemize}
	\item require a web server
	\item require PHP, Perl, Ruby, Javascript, ...
	\item which uses generic library functions
	\item which make various system calls
	\item which the kernel handles for the OS
	\item which is running in a virtual machine
	\item which is running on top of a hypervisor
	\item which uses firmware to manage various components
	\item which is running on some hardware
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
	\item guest OS kernel starts
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
	\item guest OS kernel starts
	\item kernel initializes (virtual) hardware
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
	\item guest OS kernel starts
	\item kernel initializes (virtual) hardware
	\item {\tt init(8)} (or similar) starts
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
	\item guest OS kernel starts
	\item kernel initializes (virtual) hardware
	\item {\tt init(8)} (or similar) starts
	\item system processes / daemons start
\end{itemize}

\subsection{...and back up again}
Bringin up this web service might include...
\\

\begin{itemize}
	\item power on hardware
	\item POST and other firmware initialization
	\item first stage boot loader
	\item second stage boot loader
	\item hypervisor kernel dom0 starts
	\item domU is started
	\item guest OS kernel starts
	\item kernel initializes (virtual) hardware
	\item {\tt init(8)} (or similar) starts
	\item system processes / daemons start
	\item web server runs, binds network socket, serves content
\end{itemize}


\subsection{Team Missions}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=1.0]{pics/blue-hat.eps}
\end{center}
{\tt https://is.gd/VFWyp6}
\vspace*{\fill}


\subsection{Typical Boot Sequence}
\vspace*{\fill}
\begin{center}
	\includegraphics[scale=0.8]{pics/post.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Typical Boot Sequence}
\vspace*{\fill}
\begin{center}
	\includegraphics[scale=1.5]{pics/BIOS.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Typical Boot Sequence}
\vspace*{\fill}
\begin{center}
	\includegraphics[scale=0.5]{pics/UEFI.eps} \\
Unified Extensible Firmware Interface (UEFI)
\end{center}
\vspace*{\fill}

\subsection{Team Missions}
\vspace*{\fill}
\begin{center}
\includegraphics[scale=1.3]{pics/green-hat.eps}
\end{center}
{\tt https://is.gd/KgvP8p}
\vspace*{\fill}


\subsection{Typical Boot Sequence}
\vspace*{\fill}
\begin{center}
	\includegraphics[scale=0.8]{pics/ufs-details.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Typical Boot Sequence: BIOS and MBR}
\begin{minipage}[c]{0.7\textwidth}
\begin{itemize}
	\item first sector (512 bytes) of data storage device
	\item last two bytes contain signature \verb+0x55 0xAA+
	\item 64 bytes allocated for partition table (four possible
		partitions at 16 bytes each)
	\item 446 bytes for primary boot loader code
\end{itemize}
\end{minipage}
\begin{minipage}[c]{0.1\textwidth}
\includegraphics[scale=0.7]{pics/stage1.eps} \\
\end{minipage}

\subsection{Recall HW1}
\begin{verbatim}
# fdisk /dev/xbd0
fdisk: primary partition table invalid, no magic in sector 0
Disk: /dev/xbd0d

BIOS disk geometry:
cylinders: 1023, heads: 255, sectors/track: 63 (16065 sectors/cylinder)
total sectors: 69206016

Partition table:
0: <UNUSED>
1: <UNUSED>
2: <UNUSED>
3: <UNUSED>
Bootselector disabled.
No active partition.
\end{verbatim}

\subsection{Boot partitions}
See e.g. {\tt
https://en.wikipedia.org/wiki/Master\_boot\_record\#Partition\_table\_entries}
\smallish
\begin{verbatim}
fdisk xbd2

# 0x80 = active; 0x00 inactive
printf '\x0' | dd of=/dev/xbd2d bs=1 seek=446
# CHS of first sector
printf '\01\01\00' | dd of=/dev/xbd2d bs=1 seek=447
# partition type 169 decimal = NetBSD
printf '\xa9' | dd of=/dev/xbd2d bs=1 seek=450
# CHS of last sector
printf '\x8a\x08\x82' | dd of=/dev/xbd2d bs=1 seek=451
# LBA of first sector (4 bytes, little endian)
printf '\x3f' | dd of=/dev/xbd2d bs=1 seek=454
# total # of sector (4 bytes little endian)
printf '\xc1\xff\x1f' | dd of=/dev/xbd2d bs=1 seek=458
# magic header / boot signature
printf '\x55\xaa' | dd of=/dev/xbd2d seek=510 bs=1

fdisk xbd2

# of, a bit easier:
fdisk -f -u -0 -s 169/63/2097089 /dev/rxbd2d
\end{verbatim}

\subsection{Boot partitions}
Dual boot example:
\smallish
\begin{verbatim}
# fdisk xbd2
Disk: /dev/rxbd2d

Partitions aligned to 16065 sector boundaries, offset 63

Partition table:
0: NetBSD (sysid 169)
    bootmenu: NetBSD
    start 63, size 1044162 (510 MB, Cyls 0-64)
1: Linux extended (sysid 133)
    bootmenu: Linux
    start 1044225, size 1052927 (514 MB, Cyls 65-130/138/8)
2: <UNUSED>
3: <UNUSED>
Extended partition table:
E0: Linux native (sysid 131)
    start 1044288, size 530082 (259 MB, Cyls 65-97)
E1: Linux native (sysid 131)
    start 1574433, size 522719 (255 MB, Cyls 98-130/138/8)
Bootselector enabled, timeout 10 seconds.
First active partition: 0
Drive serial number: 0 (0x00000000)
# 
\end{verbatim}
\Normalsize

\subsection{Typical Boot Sequence}
\vspace*{\fill}
\begin{center}
	\includegraphics[scale=0.8]{pics/grub.eps} \\
\end{center}
\vspace*{\fill}

\subsection{Typical Boot Sequence}
\begin{itemize}
	\item {\bf P}ower-{\bf o}n {\bf S}elf-{\bf T}est
	\item primary boot loader (e.g. BIOS, UEFI, Open Firmware / OpenBoot)
	\item transfer of execution to {\bf M}aster {\bf B}oot {\bf R}ecord or perform netbooting
	\item Second-stage boot loader (e.g. GRUB)
	\item load kernel
	\item kernel transfers control to {\tt init(8)}
\end{itemize}
\vspace{.5in}
Note: in virtualized environments, some of these steps
are skipped, repeated, or simulated. \\


\subsection{Typical Boot Sequence}
\begin{itemize}
	\item {\bf P}ower-{\bf o}n {\bf S}elf-{\bf T}est
	\item primary boot loader (e.g. BIOS, UEFI, Open Firmware / OpenBoot)
	\item transfer of execution to {\bf M}aster {\bf B}oot {\bf R}ecord or perform netbooting
	\item Second-stage boot loader (e.g. GRUB)
	\item load kernel
	\item kernel transfers control to {\tt init(8)}
\end{itemize}
\vspace{.5in}
Note: in virtualized environments, some of these steps
are skipped, repeated, or simulated. \\

\vspace{.25in}
How do you know if your system is trustworthy once it
boots up? Review ``remote attestation'' of software,
``secure boot'' mechanisms, and Trusted Computing.

\subsection{Typical Boot Sequences}
Exercise:

\verb+https://stevens.netmeister.org/615/boot-sequence/+
\vspace*{\fill}
\begin{verbatim}
$ aws ec2 run-instances --instance-type t1.micro --image-id ami-569ed93c
$ id=$(aws ec2 describe-instances --query 'Reservations[].Instances[].InstanceId')
$ aws ec2 get-console-output --instance-id ${id} | more
\end{verbatim}
\vspace{.5in}
Compare the dislabel on the {\tt /boot} device to the
output of {\tt df(1)} on the mounted partition.
What's different? \\

Review the full console output; pay attention to the
filesystem specific parts.  Can you explain what's
happening?
\vspace*{\fill}

\subsection{HW and Reading}
\verb+https://stevens.netmeister.org/615/s20-hw2.html+

\vspace{1in}
\begin{itemize}
	\item as always: manual pages for all commands
	\item {\tt fs(5)}, {\tt newfs(8)}, {\tt tunefs(8)}
	\item {\tt https://wiki.osdev.org/Partition\_Table}
	\item {\tt https://en.wikipedia.org/wiki/Master\_boot\_record}
	\item \verb+https://is.gd/8KHnQj+
	\item \verb+https://is.gd/wGgJ0e+
\end{itemize}


%\subsection{Team Missions}
%\vfill
%\begin{center}
%\includegraphics[scale=0.8]{pics/blue-hat.eps}
%\hspace{.5in}
%\includegraphics[scale=1.0]{pics/red-hat.eps}
%\end{center}
%\vfill
%
%\newpage
%\vspace*{\fill}
%\begin{center}
%	\Hugesize
%		Software Installation Concepts \\ [1em]
%	\hspace*{5mm}
%	\blueline\\
%	\hspace*{5mm}\\
%		Operating System Installation
%\end{center}
%\vspace*{\fill}
%
%
%\subsection{OS Installation}
%\begin{center}
%	\includegraphics[scale=0.7]{pics/netbsd-install.eps}
%\end{center}
%
%\subsection{OS Installation}
%\small
%\begin{verbatim}
%# fdisk -f -u -0 -s 169/63/4194241 /dev/rwd0d
%# fdisk -f -c /usr/mdec/mbr /dev/rwd0d
%# fdisk -f -a -0 /dev/rwd0d
%# disklabel -e -I wd0
%[...]
%4 partitions:
%#      size   offset fstype [fsize bsize cpg/sgs]
%a:  4194241       63 4.2BSD    0     0      0 # (Cyl.      0*- 4161*)
%c:  4194241       63 4.2BSD    0     0      0 # (Cyl.      0*- 4161*)
%d:  4194304        0 unused    0     0      0 # (Cyl.      0 - 4161*)
%# /sbin/newfs -O 2 /dev/rwd0a
%/dev/rwd0a: 2048.0MB (4194240 sectors) block size 16384,
%        fragment size 2048 using 12 cylinder groups of
%        170.67MB, 10923 blks, 21504 inodes.
%super-block backups (for fsck_ffs -b #) at:
%32, 349568, 699104, 1048640, 1398176, 1747712, 2097248, 2446784,
%....................................................................
%# mount -o async /dev/wd0a /mnt
%# for pkg in base comp etc games man misc modules text kern-GENERIC; do
%tar zxpf /i386/binary/sets/${pkg}.tgz -C /mnt
%done
%# cp /mnt/usr/mdec/boot /mnt/boot
%# /usr/sbin/installboot -v -o timeout=5 /dev/rwd0a \
%        /mnt/usr/mdec/bootxx_ffsv2
%File system:       /dev/rwd0a
%Primary bootstrap: /usr/mdec/bootxx_ffsv2
%Boot options:      timeout 5, flags 0, speed 9600, ioaddr 0, console pc
%# cd /mnt/dev && ./MAKEDEV all
%# shutdown -r now
%\end{verbatim}
%\Normalsize
%
%\subsection{OS Installation}
%General steps:
%\begin{itemize}
%	\item power up
%	\item PXE or iPXE boot
%	\begin{itemize}
%		\item network configuration / BOOTP/DHCP
%		\item boot from network via e.g., tftp miniroot
%	\end{itemize}
%	\item identify root device and optional additional disks
%	\item create partition table / disklabel
%	\item create filesystem(s)
%	\item install MBR, bootblocks etc.
%	\item fetch OS software (e.g., via HTTPS, iSCSI, ...)
%	\item install / copy / extract OS
%	\item optionally add application software
%	\item perform basic system configuration
%	\item reboot
%\end{itemize}
%
%
%\subsection{OS Installation}
%Most of the difficult parts happen outside of the
%building system:
%\begin{itemize}
%	\item hardware identification, provisioning, and registration
%	\item base OS installation
%	\item installation of add-on applications
%	\item initial minimum system configuration [*]
%	\item system registration
%	\item system restart
%\end{itemize}
%\vspace*{\fill}
%[*] system {\em deployment} $\cap$ system {\em configuration} \\
%$ => $ configuration management
%
%\subsection{Post Installation}
%\vspace*{\fill}
%\begin{center}
%	\includegraphics[scale=0.8]{pics/delete.eps}
%\end{center}
%\vspace*{\fill}
%
%\subsection{Post Installation}
%\vspace*{\fill}
%\begin{center}
%	\includegraphics[scale=1.4]{pics/duck_tape.eps}
%\end{center}
%\vspace*{\fill}
%
%\newpage
%\vspace*{\fill}
%\begin{center}
%    \Hugesize
%        Hooray! \\ [1em]
%    \hspace*{5mm}
%    \blueline\\
%    \hspace*{5mm}\\
%        5 Minute Break
%\end{center}
%\vspace*{\fill}
%
%\newpage
%\vspace*{\fill}
%\begin{center}
%	\Hugesize
%		Software Installation Concepts \\ [1em]
%	\hspace*{5mm}
%	\blueline\\
%	\hspace*{5mm}\\
%		System Software vs. Third Party Software
%\end{center}
%\vspace*{\fill}
%
%\subsection{System Software vs. Third Party Software}
%\\
%
%\vspace{.5in}
%\begin{tabularx}{\textwidth}{X | X | X | X }
%{\bf Example} & {\bf System / OS} & {\bf 3rd Party} & {\bf Packaged} \\
%\hline
%kernel & & & \\
%drivers & & & \\
%firmware & & & \\
%{\tt libc} & & & \\
%shell & & & \\
%compiler & & & \\
%{\tt ssh(1)} / {\tt sshd(8)} & & & \\
%mail server & & & \\
%web server & & & \\
%database & & & \\
%python & & & \\
%\end{tabularx}
%
%\subsection{Types of Software}
%\vfill
%\begin{center}
%	\includegraphics[scale=0.8]{pics/types-of-software.eps}
%\end{center}
%\vfill
%
%
%\subsection{System Software vs. Third Party Software}
%Consider:
%\begin{itemize}
%	\item OS upgrades vs. software upgrades
%	\item location of configuration files
%	\item duplicates or conflicting versions in the base system vs. the
%		add-ons
%	\item startup scripts, d{\ae}mons
%	\item location of third party software
%	\item dependencies
%	\item installation by hand and/or installation using a package manager
%	\item proprietary third party software
%\end{itemize}
%
%\subsection{Team Missions}
%
%\vspace*{\fill}
%\begin{center}
%\includegraphics[scale=0.35]{pics/black-hat.eps}
%\end{center}
%\vspace*{\fill}
%
%
%
%\subsection{Package Manager Features}
%\begin{itemize}
%	\item easy and scalable installation of software
%	\item automatic resolution of software dependencies
%	\item package and file inventory \\
%\begin{verbatim}
%linux-lab$ dpkg -l
%[...]
%linux-lab$ dpkg -L tcpdump
%[...]
%linux-lab$ dpkg-query -S /usr/lib/libsqlite.so.0.8.6 /usr/bin/sqlite3
%[...]
%
%\end{verbatim}
%\end{itemize}
%
%\subsection{Package Manager Features}
%\begin{itemize}
%	\item easy and scalable installation of software
%	\item automatic resolution of software dependencies
%	\item package and file inventory
%	\item integration into OS
%	\item package and file integrity checks \\
%\begin{verbatim}
%$ rpm -Va
%[...]
%missing     /etc/pki/CA/private (Permission denied)
%S.5.....  c /etc/pki/tls/certs/ca-bundle.crt
%.......T  c /etc/libuser.conf
%..?.....  c /etc/tcsd.conf
%missing   c /etc/logrotate.d/syslog
%[...]
%\end{verbatim}
%\end{itemize}
%
%\subsection{Managing Security Patches and Software Upgrades}
%How many known vulnerabilities (unique CVEs and affected packages) exist
%in each of the Fedora and Debian instances?
%
%\begin{verbatim}
%debian$ sudo apt-get install debsecan
%debian$ debsecan
%debian$ sudo apt-get update
%debian$ sudo apt-get upgrade
%debian$ debsecan
%\end{verbatim}
%
%\begin{verbatim}
%fedora$ yum list-security
%fedora$ yum info-security
%\end{verbatim}
%
%\subsection{Managing Security Patches and Software Upgrades}
%How many known vulnerabilities (unique CVEs and affected packages) exist
%in each of the Fedora and Debian instances?
%
%\begin{verbatim}
%debian$ sudo apt-get install debsecan
%debian$ debsecan
%debian$ sudo apt-get update
%debian$ sudo apt-get upgrade
%debian$ debsecan
%\end{verbatim}
%
%\begin{verbatim}
%fedora$ yum list-security
%fedora$ yum info-security
%fedora$ sudo yum update
%fedora$ yum list-security
%\end{verbatim}
%
%\vspace{.5in}
%Excellent! Now what about all the stuff you installed that
%wasn't packaged?
%
%\subsection{Special Purpose Package Managers}
%\vfill
%\begin{center}
%	\includegraphics[scale=0.8]{pics/pip.eps}
%\end{center}
%\vfill
%
%\subsection{Special Purpose Package Managers}
%\vfill
%\begin{center}
%	\includegraphics[scale=0.8]{pics/bower.eps}
%\end{center}
%\vfill
%
%
%\subsection{Special Purpose Package Managers}
%Most programming languages or environments come with their own "package
%management" solutions, often integrating/mixing with a "build system".
%\begin{itemize}
%	\item Common Lisp $=>$ quicklisp
%	\item Go $=>$ go get
%	\item NodeJS $=>$ npm
%	\item Perl $=>$ CPAN
%	\item Python $=>$ easy-install, pip, pants, setuptools, ...
%	\item Ruby $=>$ gems, rvm, rake
%	\item Scala $=>$ sbt
%	\item ...
%\end{itemize}
%
%\subsection{You don't get to choose.}
%\Huge
%\vfill
%\begin{center}
%	You routinely have to build from source {\em and} (re-)package your software.
%\end{center}
%\vfill
%\Normalsize
%
%\subsection{Dependencies, Integrity, and Trust}
%OS provider repositories:
%\begin{itemize}
%	\item {\tt yum update} / {\tt yum install}
%	\item {\tt apt-get}
%\end{itemize}
%\vspace{.5in}
%Language-specific community repositories:
%\begin{itemize}
%	\item {\tt gem install foo}
%	\item {\tt go get github.com/randomAccount/randomRepository}
%	\item {\tt npm install -g foo}
%	\item {\tt perl -MCPAN -e 'install Something::YouWant'}
%	\item {\tt pip install foo}
%\end{itemize}
%\vspace{.5in}
%
%What could possibly go wrong?
%
%\subsection{Dependencies, Integrity, and Trust}
%Fun fact: \\
%
%\begin{verbatim}
%$ wget http://somewhere/some.tar.gz
%$ tar zxf some.tar.gz
%$ cd some
%$ ./configure
%$ make
%$ sudo make install
%\end{verbatim}
%\vspace{.5in}
%is not inherently better than \\
%
%\begin{verbatim}
%$ curl http://somewhere/script.sh | sudo bash
%\end{verbatim}
%
%\subsection{Dependencies, Integrity, and Trust}
%\begin{center}
%Mirroring untrusted, unverified dependencies\\
%does not solve any of your problems. \\
%\vspace{.5in}
%
%Integrity verification is meaningless \\
%without assurance of trust. \\
%\vspace{.5in}
%
%Dependencies are called dependencies \\
%because you {\em depend} on them. \\
%\vspace{.5in}
%
%Dependency trust and integrity is recursive. \\
%\vspace{.5in}
%\end{center}
%
%\subsection{Dependencies, Integrity, and Trust}
%\begin{center}
%Mirroring untrusted, unverified dependencies\\
%does not solve any of your problems. \\
%\vspace{.5in}
%
%Integrity verification is meaningless \\
%without assurance of trust. \\
%\vspace{.5in}
%
%Dependencies are called dependencies \\
%because you {\em depend} on them. \\
%\vspace{.5in}
%
%Dependency trust and integrity is recursive. \\
%\vspace{.5in}
%
%{\em Remember Left-Pad!}
%\end{center}
%
%\subsection{Exercises}
%All recommended, none graded: \\
%\verb+https://stevens.netmeister.org/615/package-exercise.html+
%
%\vspace{.25in}
%Identify a piece of software you use, but that's not
%packaged for a given package manager.  Create a
%package for it, then contribute upstream.
%
%\vspace{.25in}
%Create a cheat sheet for 4 different package managers,
%listing the more important equivalent commands.
%
%\vspace{.25in}
%How does your preferred OS update firmware?
%
%\vspace{.25in}
%How does the concept of {\em reproducable builds}
%relate to what we discussed here?
%
%\vspace{.25in}
%What is the overlap with system {\em configuration}? Can a
%package manager assert state?
%
%\subsection{Links}
%Booting virtual machines:
%\begin{itemize}
%	\item {\tt https://wiki.xen.org/wiki/PvGrub}
%	\item {\tt https://is.gd/JnD9jM}
%	\item {\tt https://is.gd/TAVCQF}
%	\item {\tt https://is.gd/EiOu6v}
%\end{itemize}
%
%\subsection{Links}
%NPM and LeftPad: \\
%{\tt http://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm} \\
%{\tt http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/} \\
%{\tt http://www.businessinsider.com/npm-left-pad-controversy-explained-2016-3}
%
%\subsection{Links}
%\begin{itemize}
%	\item \verb+http://www.pathname.com/fhs/+
%	\item hier(7)
%	\item your package managers' manual pages
%		\begin{itemize}
%			\item pkg\_info(1)
%			\item pkginfo(1), pkgadd(1M)
%			\item rpm(1)
%			\item ...
%		\end{itemize}
%	\item \verb+http://www.pkgsrc.org/+
%\end{itemize}

\subsection{Additional Content}

Content for topics we couldn't fit into class below.
\\
Please review on your own time.


\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=0.7]{pics/file.eps}} \\
\end{tabular}
\\

\verb+$ stat /etc/passwd+


\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
	\item directories
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=1.5]{pics/directory.eps}} \\
\end{tabular}
\\

\verb+$ stat /+

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
	\item directories
	\item special files
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=1.0]{pics/devices.eps}} \\
\end{tabular}
\\

\verb+$ file /dev/* | more+

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
	\item directories
	\item special files
	\item links
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=0.6]{pics/link.eps}} \\
\end{tabular}
\\

\begin{verbatim}
$ touch /tmp/foo
$ ln /tmp/foo /tmp/bar
$ stat /tmp/foo /tmp/bar
$ ln -sf /tmp/foo /tmp/bar
$ stat /tmp/foo /tmp/bar
\end{verbatim}

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
	\item directories
	\item special files
	\item links
	\item sockets
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=0.8]{pics/socket.eps}} \\
\end{tabular}
\\

\verb+$ stat /dev/log+

\subsection{Basic Filesystem Concepts: The UNIX Filesystem}
File types:
\\

\begin{tabular}{ p{10cm} S }
\begin{itemize}
	\item regular files
	\item directories
	\item special files
	\item links
	\item sockets
	\item named pipes
\end{itemize}
& \multirow{2}{*}{\includegraphics[scale=1.0]{pics/pipe.eps}} \\
\end{tabular}
\\

\begin{verbatim}
$ mkfifo /tmp/fifo
$ cat /tmp/fifo > /tmp/out &
$ stat /tmp/fifo | tee /tmp/fifo
$ cat /tmp/out
\end{verbatim}

\newpage
\vspace*{\fill}
\begin{center}
	\Hugesize
		Basic Filesystem Concepts\\ [1em]
	\hspace*{5mm}
	\blueline\\
	\hspace*{5mm}\\
		Filesystem Layout
\end{center}
\vspace*{\fill}

\subsection{Basic Filesystem Concepts}
All partitions -- with the exception of the {\em root} (or \verb+/+) partition
-- can be {\em mounted} anywhere in the filesystem hierarchy.
\\

\begin{center}
	\includegraphics[scale=0.5]{pics/filesystem-tree-mountpoints.eps} \\
\end{center}

\subsection{Basic Filesystem Concepts}
All partitions -- with the exception of the {\em root} (or \verb+/+) partition
-- can be {\em mounted} anywhere in the filesystem hierarchy.
\\

The file \verb+/etc/fstab+ (see fstab(5)) specifies which disks / partitions
to mount where:
\\
\begin{verbatim}
/dev/xbd1a /        ffs    rw 1 1
/dev/xbd0a /grub    ext2fs rw 2 2
kernfs     /kern    kernfs rw
ptyfs      /dev/pts ptyfs  rw
procfs     /proc    procfs rw
\end{verbatim}
\Normalsize

\subsection{Basic Filesystem Concepts}
All partitions -- with the exception of the {\em root} (or \verb+/+) partition
-- can be {\em mounted} anywhere in the filesystem hierarchy.
\\

The file \verb+/etc/fstab+ (see fstab(5)) specifies which disks / partitions
to mount where:
\\
\begin{verbatim}
$ cat /etc/fstab
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
/dev/mapper/nemo--vg-root /               ext4    errors=remount-ro 0       1
# /boot was on /dev/sda1 during installation
UUID=e5abfdb9-1d53-4df7-9894-1c5a08b7f8c7 /boot           ext2    defaults        0       2
/dev/mapper/nemo--vg-swap_1 none            swap    sw              0       0
\end{verbatim}


\subsection{Basic Filesystem Concepts}
All partitions -- with the exception of the {\em root} (or \verb+/+) partition
-- can be {\em mounted} anywhere in the filesystem hierarchy.
\\

To see what filesystems are currently mounted, run \verb+mount(8)+:
\\

\begin{verbatim}
/dev/xbd1a on / type ffs (local)
/dev/xbd0a on /grub type ext2fs (local)
kernfs on /kern type kernfs (local)
ptyfs on /dev/pts type ptyfs (local)
procfs on /proc type procfs (local)
/dev/xbd2a on /mnt type ffs (local)
\end{verbatim}


\subsection{Basic Filesystem Concepts}
\\

\begin{verbatim}
$ mount
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1002928k,nr_inodes=250732,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204804k,mode=755)
/dev/mapper/nemo--vg-root on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
/dev/vda1 on /boot type ext2 (rw,relatime,block_validity,barrier,user_xattr,acl)
ldap:nirvana.phy.stevens-tech.edu:ou=auto.home,dc=phy,dc=stevens-tech,dc=edu on /home type autofs (rw,relatime,fd=6,pgrp=1345,timeout=60,minproto=5,maxproto=5,indirect)
kronos.srcit.stevens-tech.edu:/xraid0-1/export/home/jschauma on /home/jschauma type nfs (rw,relatime,sync,vers=3,rsize=32768,wsize=32768,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=155.246.89.203,mountvers=3,mountport=53643,mountproto=udp,local_lock=none,addr=155.246.89.203)
\end{verbatim}

\subsection{Basic Filesystem Concepts}
Some of the different kinds of filesystems:
\begin{itemize}
	\item ``Regular'' File Systems
	\item Journaling File Systems
	\item Network File Systems
	\item Various
\end{itemize}


\subsection{Where do we put all of our files?}
Layout of filesystem {\em should} be standardized.  Some UNIX versions adhere
to these standards, some are strongly influenced by tradition.
\\

{\tt man hier}

\subsection{File System Hierarchy}
\small
\begin{verbatim}
                     /          root directory of the system

                     /bin/      utilities used in both single and multi-user environments

                     /dev/      block, character and other special device files

                     /etc/      system configuration files and scripts

                     /lib/      dynamic linked libraries used by dynamic linked programs (such
                                as those in /bin/ and /sbin/) that cannot rely upon /usr/lib/
                                being available.

                     /sbin/     system programs and administration utilities used in both sin-
                                gle-user and multi-user environments

                     /tmp/      temporary files, usually a mfs(8) memory-based filesystem (the
                                contents of /tmp are usually not preserved across a system
                                reboot)

                     /usr/      contains the majority of the system utilities and files


                                bin/      common utilities, programming tools, and applica-
                                          tions

                                lib/      archive, profiled, position independent archive, and
                                          shared libraries

                                sbin/     system daemons and system utilities (normally exe-
                                          cuted by the super-user)

                                share/    architecture-independent text files
\end{verbatim}
\Normalsize



\end{document}
